<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hacker-Terminal V3</title>

    <!-- Import der THREE.js-Bibliothek für 3D-Grafiken -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        /* ========================================================================= */
        /* ALLGEMEINES STYLING UND FONT */
        /* ========================================================================= */
        html,
        body {
            height: 100%;
            margin: 0;
            background: #000;
            color: #00FF00;
            font-family: 'VT323', monospace;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden;
            position: relative;
        }

        /* ========================================================================= */
        /* LADEBILDSCHIRM-STYLING (Hacker-Animation) */
        /* ========================================================================= */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1.5s ease-in-out;
            text-align: center;
        }

        #sphere-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #loading-text {
            position: absolute;
            font-size: clamp(1rem, 4vw, 2.5rem);
            color: #00FF00;
            text-shadow: 0 0 10px #00FF00;
            z-index: 12;
            white-space: nowrap;
            transition: opacity 0.5s ease-in-out;
        }

        #loading-log {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 450px;
            max-height: 250px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            border: 2px solid #00FF00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.7);
            z-index: 13;
            padding: 15px;
            overflow-y: auto;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .log-line {
            color: #00FF00;
            margin: 0;
            white-space: pre-wrap;
            opacity: 0;
            animation: fadeIn 0.5s forwards;
            animation-delay: var(--delay);
        }

        .status-ok {
            color: #00FF00;
        }

        .status-info {
            color: #FFFF00;
        }

        .status-warn {
            color: #FFA500;
        }

        .status-fail {
            color: #FF0000;
        }

        .status-success {
            color: #00FF00;
        }

        #progress-bar-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 25px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #00FF00;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
            overflow: hidden;
            z-index: 13;
            opacity: 0;
            transition: opacity 1s ease;
        }

        #progress-bar-fill {
            height: 100%;
            width: 0%;
            background-color: #00FF00;
            transition: width 0.5s ease-out;
            box-shadow: 0 0 8px #00FF00;
        }

        #access-granted {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(3.5rem, 12vw, 6rem);
            text-shadow: 0 0 25px #00FF00, 0 0 50px rgba(0, 255, 0, 0.7);
            animation: glitch-anim 0.6s infinite linear alternate, fadeIn 1.2s forwards;
            display: none;
            opacity: 0;
            z-index: 11;
            transition: opacity 1.2s ease-in-out;
        }

        .glitch-text {
            animation: glitch-anim 2.5s infinite linear alternate;
        }

        @keyframes glitch-anim {
            0% { text-shadow: none; }
            10% { text-shadow: 0.04em 0.03em 0 #00FF00, -0.02em -0.02em 0 #00FFFF, 0.03em 0.04em 0 #FFFF00; }
            20% { text-shadow: none; }
            30% { text-shadow: 0.02em 0.03em 0 #FF0000, -0.04em -0.02em 0 #00FFFF, 0.02em 0.03em 0 #00FF00; }
            40% { text-shadow: none; }
            50% { text-shadow: -0.03em -0.04em 0 #00FFFF, 0.03em 0.02em 0 #FF0000, -0.02em -0.03em 0 #00FF00; }
            60% { text-shadow: none; }
            70% { text-shadow: 0.04em 0.02em 0 #00FF00, -0.03em -0.03em 0 #FFFF00, 0.04em 0.02em 0 #FF0000; }
            80% { text-shadow: none; }
            90% { text-shadow: -0.02em -0.04em 0 #FFFF00, 0.03em 0.03em 0 #00FFFF, -0.04em -0.02em 0 #00FF00; }
            100% { text-shadow: none; }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        /* ========================================================================= */
        /* DESKTOP-STYLING */
        /* ========================================================================= */
        #desktop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 50;
            display: none;
            flex-direction: row;
            flex-wrap: wrap;
            align-items: flex-start;
            padding: 20px;
            gap: 20px;
            transition: opacity 0.3s ease;
        }
        #desktop.hidden {
          opacity: 0;
          pointer-events: none;
        }

        .desktop-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 120px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .desktop-icon:hover {
            background-color: rgba(0, 255, 0, 0.1);
            border-radius: 8px;
        }

        .icon-svg {
            width: 60px;
            height: 60px;
            fill: #00FF00;
            filter: drop-shadow(0 0 8px rgba(0, 255, 0, 0.6));
        }

        .icon-label {
            margin-top: 8px;
            color: #00FF00;
            text-shadow: 0 0 5px #00FF00;
            font-size: 1.2rem;
            text-align: center;
            font-weight: bold;
        }

        /* ========================================================================= */
        /* MAIN APP STYLING (TERMINAL & SCHACH) */
        /* ========================================================================= */
        #newTerminalBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            display: none;
            padding: 8px 12px;
            background-color: #0a0a0a;
            color: #00FF00;
            border: 2px solid #00FF00;
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            text-shadow: 0 0 10px #00FF00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.7);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 50;
        }

        #newTerminalBtn:hover {
            background-color: #001a00;
            box-shadow: 0 0 25px rgba(0, 255, 0, 1);
            transform: scale(1.05);
        }

        .terminal-window {
            width: 70%;
            max-width: none;
            height: 80%;
            max-height: none;
            background-color: #000;
            border: 2px solid #00FF00;
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.7);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            resize: none;
            border-radius: 8px;
            position: absolute;
            z-index: 2;
        }

        .terminal-header {
            background-color: #0a0a0a;
            color: #00FF00;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid #00FF00;
            cursor: grab;
        }

        .terminal-header h2 {
            margin: 0;
            font-size: 1.2rem;
            text-shadow: 0 0 6px #00FF00;
        }

        .close-btn {
            background-color: transparent;
            color: #00FF00;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s ease, text-shadow 0.3s ease;
            text-shadow: 0 0 8px #00FF00;
        }

        .close-btn:hover {
            color: #FF0000;
            text-shadow: 0 0 12px #FF0000;
        }

        .terminal-output {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
            background-color: rgba(13, 13, 13, 0.6);
            -ms-overflow-style: none;
            scrollbar-width: none;
            font-size: 1.1rem;
            line-height: 1.2;
            white-space: pre-wrap;
        }

        .terminal-output::-webkit-scrollbar {
            display: none;
        }

        .log-entry {
            max-width: 100%;
            word-wrap: break-word;
            font-family: 'VT323', monospace;
            color: #00FF00;
        }

        .user-input-line {
            color: #FFFFFF;
            font-weight: bold;
        }

        .terminal-input-container {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            background-color: rgba(13, 13, 13, 0.95);
            border-top: 2px solid #00FF00;
            font-size: 1.1rem;
        }

        .prompt-symbol {
            color: #00FF00;
            font-size: 1.2rem;
            margin-right: 8px;
        }

        .terminal-input-container input[type="text"] {
            flex-grow: 1;
            border: none;
            background-color: transparent;
            color: #00FF00;
            font-size: 1.1rem;
            outline: none;
            font-family: 'VT323', monospace;
        }

        .terminal-input-container button {
            background-color: #008800;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 400;
            transition: transform 0.3s ease, box-shadow 0.4s ease;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.6);
            font-family: 'VT323', monospace;
        }

        .terminal-input-container button:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 12px rgba(0, 255, 0, 0.8);
        }

        /* ========================================================================= */
        /* MODAL STYLING (für Spielende & Speichern) */
        /* ========================================================================= */
        .hacker-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 9998;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hacker-modal {
            background: linear-gradient(180deg, rgba(0,0,0,0.98), rgba(5,5,5,0.95));
            border: 3px solid #00ff00;
            padding: 25px;
            z-index: 9999;
            text-align: center;
            color: #00ff00;
            font-family: 'VT323', monospace;
            box-shadow: 0 0 40px rgba(0,255,0,0.3);
            border-radius: 12px;
        }
        .hacker-modal h2 {
            margin-top: 0;
            font-size: 1.8rem;
            text-shadow: 0 0 10px #00ff00;
        }
        .hacker-modal p {
            font-size: 1.1rem;
            margin-bottom: 20px;
        }
        .hacker-modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        .hacker-btn {
            background: transparent;
            color: #00FF00;
            border: 2px solid #00FF00;
            padding: 10px 20px;
            font-size: 1.2rem;
            font-family: 'VT323', monospace;
            cursor: pointer;
            text-shadow: 0 0 6px #00FF00;
            box-shadow: 0 0 12px rgba(0,255,0,0.7);
            border-radius: 6px;
            transition: all 0.2s ease-in-out;
        }
        .hacker-btn:hover {
            background: #002a00;
            box-shadow: 0 0 20px #00FF00;
            transform: scale(1.05) translateY(-2px);
        }
        .hacker-btn.primary {
            background: #003300;
        }

        /* ========================================================================= */
        /* SCHACH-STYLING */
        /* ========================================================================= */
        .chess-window .terminal-header {
             cursor: grab;
        }
        .chess-board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            width: 100%;
            box-sizing: border-box;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            aspect-ratio: 1 / 1;
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            border: 2px solid #00ff00;
            box-sizing: border-box;
        }

        .chess-square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            position: relative;
            overflow: visible;
            font-size: 2.5vmin; 
        }

        .chess-piece-img {
            width: 86%;
            height: 86%;
            object-fit: contain;
            pointer-events: none;
            display: block;
            transition: transform 0.2s ease;
        }
        
        .chess-square:hover .chess-piece-img {
            transform: translateY(-6%) scale(1.06);
        }
        
        .last-move-from {
          background-color: rgba(0, 255, 0, 0.3) !important;
        }

        .last-move-to {
          background-color: rgba(255, 255, 0, 0.3) !important;
        }

        .chess-topbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            width: 100%;
            max-width: 75vh;
            padding: 0 5px;
            box-sizing: border-box;
        }

        .chess-controls-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .elo-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #elo-slider {
            -webkit-appearance: none;
            width: 120px;
            height: 5px;
            background: #003300;
            outline: none;
            border: 1px solid #00FF00;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        #elo-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background: #00FF00;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px #00FF00;
        }
        
        #elo-value {
             font-weight: bold;
             min-width: 40px;
        }

        #thinking-indicator {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: #00ff00;
            padding: 15px 25px;
            border-radius: 8px;
            border: 2px solid #00ff00;
            box-shadow: 0 0 20px #00ff00;
            z-index: 1001;
            font-size: 1.5rem;
        }

        .promotion-modal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            display: none;
        }

        .promotion-modal.visible {
            display: flex;
        }

        .promotion-box {
            background: #0b0b0b;
            border: 2px solid #00FF00;
            box-shadow: 0 8px 30px rgba(0, 255, 0, 0.06);
            padding: 18px;
            border-radius: 10px;
            text-align: center;
            min-width: 260px;
        }

        .promotion-title {
            font-family: 'VT323', monospace;
            color: #00FF00;
            margin-bottom: 10px;
            font-size: 1.15rem;
        }

        .promotion-options {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .promote-btn {
            background: transparent;
            color: #00FF00;
            border: 1px solid #00FF00;
            padding: 8px 10px;
            border-radius: 6px;
            font-family: 'VT323', monospace;
            cursor: pointer;
            transition: transform 120ms ease, box-shadow 120ms ease;
        }

        .promote-btn:hover {
            transform: translateY(-6%);
            box-shadow: 0 0 14px rgba(0, 255, 0, 0.08);
        }

        .chess-control {
            margin-top: 15px;
            display: flex;
            justify-content: center;
        }

        #new-game-btn {
            background: transparent;
            color: #00FF00;
            border: 2px solid #00FF00;
            padding: 8px 16px;
            font-size: 1.2rem;
            font-family: 'VT323', monospace;
            cursor: pointer;
            text-shadow: 0 0 6px #00FF00;
            box-shadow: 0 0 12px #00FF00;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        #new-game-btn:hover {
            background: #001a00;
            color: #00FF00;
            box-shadow: 0 0 20px #00FF00;
            transform: scale(1.1);
        }

        .light {
            background-color: #555;
        }

        .dark {
            background-color: #222;
        }

        .selected {
            background-color: rgba(0, 204, 0, 0.7);
        }

        .highlight-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30%;
            height: 30%;
            background: rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            box-shadow: 0 0 15px #00FF00;
            animation: pulse 1s infinite alternate;
        }
        
        .highlight-capture::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            height: 85%;
            background: transparent;
            border-radius: 50%;
            box-sizing: border-box;
            border: 4px dashed rgba(255, 0, 0, 0.7);
            animation: pulse-red 1s infinite alternate;
        }

        @keyframes pulse {
            from { opacity: 0.7; transform: translate(-50%,-50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%,-50%) scale(1.1); }
        }

        @keyframes pulse-red {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }

        /* ========================================================================= */
        /* REPLAY VIEWER STYLING */
        /* ========================================================================= */
        .replay-viewer-container {
            padding: 15px;
            box-sizing: border-box;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
            font-size: 1.1rem;
        }
        .replay-controls-top {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        #replay-search-input {
            flex: 1;
            padding: 8px 12px;
            background: #0a0a0a;
            color: #00ff00;
            border: 1px solid #00ff00;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            outline: none;
        }
        .replay-list-container {
            flex: 1;
            overflow-y: auto; /* SCROLLEN HIER AKTIVIERT */
            border: 1px solid #003300;
            padding: 10px;
            background: rgba(0,0,0,0.3);
        }
        .replay-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            border-bottom: 1px dashed rgba(0, 255, 0, 0.2);
            padding: 8px 4px;
            cursor: pointer;
        }
        .replay-list-item:hover {
            background: rgba(0, 255, 0, 0.1);
        }
        .replay-player-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }
        #replay-board-viewer {
            width: 100%;
            max-width: 80vh;
            aspect-ratio: 1/1;
            border: 2px solid #00ff00;
        }
        .replay-player-controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #replay-pos-viewer {
            font-weight: bold;
            min-width: 60px;
            text-align: center;
            font-size: 1.3rem;
        }

    </style>
</head>

<body>

    <!-- ========================================================================= -->
    <!-- Ladebildschirm-Struktur (Hacker-Animation) -->
    <!-- ========================================================================= -->
    <div id="loader">
        <div id="sphere-container"></div>
        <div id="loading-text">Starte System...</div>
        <div id="loading-log"></div>
        <div id="progress-bar-container">
            <div id="progress-bar-fill"></div>
        </div>
        <div id="access-granted">
            <span class="glitch-text">SYSTEM ONLINE</span>
        </div>
    </div>

    <!-- ========================================================================= -->
    <!-- DESKTOP-ANSICHT -->
    <!-- ========================================================================= -->
    <div id="desktop">
        <div class="desktop-icon" id="console-icon">
            <svg class="icon-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M20 3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM4 19V5h16l-.001 14H4zm1-3h14v1H5v-1zm0-3h14v1H5v-1zm0-3h14v1H5v-1z" />
            </svg>
            <span class="icon-label">Konsole</span>
        </div>
        <div class="desktop-icon" id="chess-icon">
            <svg class="icon-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L8 12v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
            </svg>
            <span class="icon-label">Schach</span>
        </div>
        <div class="desktop-icon" id="replay-icon">
            <svg class="icon-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 5V1L8 5l4 4V6c3.87 0 7 3.13 7 7 0 1.3-.34 2.52-.94 3.6L20.9 18C21.6 16.76 22 15.42 22 14c0-5.52-4.48-10-10-10zm0 15c-3.87 0-7-3.13-7-7 0-1.3.34-2.52.94-3.6L3.1 8C2.4 9.24 2 10.58 2 12c0 5.52 4.48 10 10 10v4l4-4-4-4v3z"/></svg>
            <span class="icon-label">Replays</span>
        </div>
    </div>

    <!-- ========================================================================= -->
    <!-- Haupt-Button zum Öffnen neuer Terminals -->
    <!-- ========================================================================= -->
    <button id="newTerminalBtn">[ + ]</button>

    <!-- HIER KOMMT DAS TEMPLATE FÜR DAS SPIELENDE-MODAL -->
    <template id="game-over-modal-template">
        <div class="hacker-modal-overlay">
            <div class="hacker-modal">
                <h2 id="modal-title">Partie beendet!</h2>
                <p id="modal-text">Möchtest du die Partie speichern?</p>
                <div class="hacker-modal-buttons">
                    <button class="hacker-btn" id="modal-action-save">Speichern</button>
                    <button class="hacker-btn primary" id="modal-action-new">Neues Spiel</button>
                    <button class="hacker-btn" id="modal-action-close">Schließen</button>
                </div>
            </div>
        </div>
    </template>
    
    <!-- ========================================================================= -->
    <!-- JAVASCRIPT FÜR LADEANIMATION, CHAT-LOGIK & MULTIPLE FENSTER -->
    <!-- ========================================================================= -->
    <script>
        // === Globale DOM-Elementreferenzen ===
        const loader = document.getElementById('loader');
        const sphereContainer = document.getElementById('sphere-container');
        const loadingText = document.getElementById('loading-text');
        const loadingLog = document.getElementById('loading-log');
        const progressBarContainer = document.getElementById('progress-bar-container');
        const progressBar = document.getElementById('progress-bar-fill');
        const accessGranted = document.getElementById('access-granted');
        const newTerminalBtn = document.getElementById('newTerminalBtn');
        const desktop = document.getElementById('desktop');
        const consoleIcon = document.getElementById('console-icon');
        const chessIcon = document.getElementById('chess-icon');
        const replayIcon = document.getElementById('replay-icon');

        // === API-Konstanten und Chat-Status ===
        const apiKey = "AIzaSyB-0z8e59quUM-EaRl0tGiK-5eVaSUq3dQ";
        let highestZIndex = 2; // Start-Z-Index für Terminals

        // =========================================================================
        // THREE.JS SETUP FÜR 3D-LADEANIMATION
        // =========================================================================
        // AN DIESEM TEIL WURDE NICHTS GEÄNDERT, UM DIE STARTANIMATION ZU ERHALTEN
        let scene, camera, renderer, particles, particleMaterial, stars;
        let wireframeGlobe;
        const particleInfo = [];
        const chaosBounds = 10;
        const sphereRadius = 2.0;
        const particleCount = 3500;
        let animationPhase = 'chaos';
        let clock, phaseStartTime, orbitStartTime;
        function init3D(){scene=new THREE.Scene();camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,0.1,2000);camera.position.z=9.5;renderer=new THREE.WebGLRenderer({antialias:!0,alpha:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));sphereContainer.appendChild(renderer.domElement);const globeGeometry=new THREE.IcosahedronGeometry(sphereRadius,4);const globeMaterial=new THREE.MeshBasicMaterial({color:0x00ff00,wireframe:!0,transparent:!0,opacity:0.0});wireframeGlobe=new THREE.Mesh(globeGeometry,globeMaterial);scene.add(wireframeGlobe);const positions=new Float32Array(particleCount*3);const tempSphere=new THREE.SphereGeometry(sphereRadius,32,32);const surfaceVerts=tempSphere.attributes.position.array;for(let i=0;i<particleCount;i++){const x=(Math.random()-.5)*chaosBounds*2;const y=(Math.random()-.5)*chaosBounds*2;const z=(Math.random()-.5)*chaosBounds*2;positions[i*3]=x;positions[i*3+1]=y;positions[i*3+2]=z;const vi=Math.floor(Math.random()*(surfaceVerts.length/3));const target=new THREE.Vector3(surfaceVerts[vi*3],surfaceVerts[vi*3+1],surfaceVerts[vi*3+2]);const innerScale=.28+Math.random()*.32;const innerTarget=target.clone().multiplyScalar(innerScale);const velocity=new THREE.Vector3((Math.random()-.5)*.04,(Math.random()-.5)*.04,(Math.random()-.5)*.04);particleInfo.push({target,innerTarget,velocity,state:'idle',stagingPoint:null})}const geometry=new THREE.BufferGeometry();geometry.setAttribute('position',new THREE.BufferAttribute(positions,3));particleMaterial=new THREE.PointsMaterial({color:0x00ff00,size:.03,transparent:!0,opacity:.9});particles=new THREE.Points(geometry,particleMaterial);scene.add(particles);const starsGeo=new THREE.BufferGeometry();const starPositions=[];for(let i=0;i<3000;i++){starPositions.push((Math.random()-.5)*2000,(Math.random()-.5)*2000,(Math.random()-.5)*2000)}starsGeo.setAttribute('position',new THREE.Float32BufferAttribute(starPositions,3));const starsMat=new THREE.PointsMaterial({color:0x00ff00,size:1.5,transparent:!0,opacity:.45});stars=new THREE.Points(starsGeo,starsMat);scene.add(stars);clock=new THREE.Clock();phaseStartTime=clock.getElapsedTime();window.addEventListener('resize',onWindowResize)}
        function animate3D(){requestAnimationFrame(animate3D);const dt=clock.getDelta();const t=clock.getElapsedTime();const positions=particles.geometry.attributes.position.array;switch(animationPhase){case'chaos':for(let i=0;i<particleCount;i++){positions[i*3]+=particleInfo[i].velocity.x;positions[i*3+1]+=particleInfo[i].velocity.y;positions[i*3+2]+=particleInfo[i].velocity.z;if(Math.abs(positions[i*3])>chaosBounds)particleInfo[i].velocity.x*=-1;if(Math.abs(positions[i*3+1])>chaosBounds)particleInfo[i].velocity.y*=-1;if(Math.abs(positions[i*3+2])>chaosBounds)particleInfo[i].velocity.z*=-1}if(t-phaseStartTime>2.8){animationPhase='converging';phaseStartTime=t}break;case'converging':let settledCount=0;for(let i=0;i<particleCount;i++){const px=positions[i*3],py=positions[i*3+1],pz=positions[i*3+2];const p=new THREE.Vector3(px,py,pz);const target=particleInfo[i].target;p.lerp(target,.045+Math.random()*.01);positions[i*3]=p.x;positions[i*3+1]=p.y;positions[i*3+2]=p.z;if(p.distanceTo(target)<.09)settledCount++}const settledPerc=settledCount/particleCount;wireframeGlobe.material.opacity=Math.min(1,settledPerc*1.6);if(settledPerc>.96||(clock.getElapsedTime()-phaseStartTime>7.5)){prepareXInflow();animationPhase='xInflow';phaseStartTime=clock.getElapsedTime()}break;case'xInflow':let inflowSettled=0;for(let i=0;i<particleCount;i++){const idx=i*3;const p=new THREE.Vector3(positions[idx],positions[idx+1],positions[idx+2]);const info=particleInfo[i];const dist=p.length();if(!info.state||info.state==='idle'){if(dist>sphereRadius+.06){info.state='toStaging';info.stagingPoint=computeStagingPoint(p)}else{info.state='toInner'}}if(info.state==='toStaging'){const sp=info.stagingPoint;p.lerp(sp,.10+Math.random()*.03);positions[idx]=p.x;positions[idx+1]=p.y;positions[idx+2]=p.z;if(p.distanceTo(sp)<.12){info.state='toInner'}}else if(info.state==='toInner'){const inner=info.innerTarget;const toInner=inner.clone().sub(p);const swirl=new THREE.Vector3(-toInner.y,toInner.x,toInner.z*.08).multiplyScalar(.004+(i%7)*.0002);p.add(swirl);p.lerp(inner,.038+Math.random()*.012);positions[idx]=p.x;positions[idx+1]=p.y;positions[idx+2]=p.z;if(p.distanceTo(inner)<.055){info.state='settled'}}else if(info.state==='settled'){inflowSettled++}}wireframeGlobe.material.opacity=Math.max(.18,1.0-inflowSettled/particleCount*.9);if(inflowSettled/particleCount>.98||(clock.getElapsedTime()-phaseStartTime>12.0)){animationPhase='orbit';orbitStartTime=clock.getElapsedTime();phaseStartTime=clock.getElapsedTime()}break;case'orbit':const elapsedOrbit=(clock.getElapsedTime()-orbitStartTime);let doneCount=0;for(let i=0;i<particleCount;i++){const idx=i*3;const p=new THREE.Vector3(positions[idx],positions[idx+1],positions[idx+2]);const baseAngle=(i/particleCount)*Math.PI*2;const angle=baseAngle+elapsedOrbit*.6+(i%137)*.003;const orbitRadius=sphereRadius*(1.6+.6*Math.sin(elapsedOrbit*.9+i*.017));const ox=Math.cos(angle)*orbitRadius;const oz=Math.sin(angle)*orbitRadius;const oy=Math.sin(angle*2+i*.01)*.55;const orbitTarget=new THREE.Vector3(ox,oy,oz);p.lerp(orbitTarget,.06+(i%11)*.0014);positions[idx]=p.x;positions[idx+1]=p.y;positions[idx+2]=p.z;if(p.length()>sphereRadius*1.55)doneCount++}wireframeGlobe.material.opacity=.95;if(doneCount/particleCount>.98){}break}wireframeGlobe.rotation.y+=.0025;if(stars)stars.rotation.y+=.0001;particles.geometry.attributes.position.needsUpdate=!0;renderer.render(scene,camera)}
        function prepareXInflow(){for(let i=0;i<particleCount;i++){const idx=i*3;const pos=new THREE.Vector3(particles.geometry.attributes.position.array[idx],particles.geometry.attributes.position.array[idx+1],particles.geometry.attributes.position.array[idx+2]);const dist=pos.length();if(dist>sphereRadius+.06){particleInfo[i].state='toStaging';particleInfo[i].stagingPoint=computeStagingPoint(pos)}else{particleInfo[i].state='toInner';particleInfo[i].stagingPoint=null}}}
        function computeStagingPoint(currentPos){const diags=[new THREE.Vector3(1,1,0).normalize(),new THREE.Vector3(-1,1,0).normalize(),new THREE.Vector3(1,-1,0).normalize(),new THREE.Vector3(-1,-1,0).normalize()];const proj=new THREE.Vector3(currentPos.x,currentPos.y,0);let bestIdx=0;let bestDot=-Infinity;const projNorm=proj.length()>.0001?proj.clone().normalize():new THREE.Vector3(1,1,0).normalize();for(let j=0;j<diags.length;j++){const d=diags[j];const dot=projNorm.dot(d);if(dot>bestDot){bestDot=dot;bestIdx=j}}const dist=sphereRadius*(1.25+Math.random()*.45);const base=diags[bestIdx].clone().multiplyScalar(dist);const zVar=(currentPos.z*.18)+(Math.random()-.5)*.35;base.z=zVar;return base}
        function onWindowResize(){const w=window.innerWidth,h=window.innerHeight;camera.aspect=w/h;camera.updateProjectionMatrix();renderer.setSize(w,h)}
        
        // =========================================================================
        // CHAT-LOGIK
        // =========================================================================
        function displayMessage(messagesDiv, message, sender) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('log-entry');
            if (sender === 'user') {
                const userLine = document.createElement('span');
                userLine.classList.add('user-input-line');
                userLine.textContent = `> ${message}`;
                messageElement.appendChild(userLine);
            } else {
                messageElement.innerHTML = `> ${message.replace(/\n/g, '<br>')}`;
            }
            messagesDiv.appendChild(messageElement);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        async function getGeminiResponse(userPrompt) {
            if (!apiKey) {
                console.error("API-Schlüssel fehlt.");
                return "Entschuldigung, es gab einen Konfigurationsfehler.";
            }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{role: 'user', parts: [{text: userPrompt}]}],
                tools: [{"google_search": {}}],
                systemInstruction: {parts: [{text: "Du bist ein KI-Assistent von Google. Antworte hilfreich und freundlich auf Deutsch. Formatiere Antworten mit Markdown."}]}
            };
            try {
                const response = await fetch(apiUrl, {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload)});
                if (!response.ok) throw new Error(`API-Fehler: ${response.status}`);
                const result = await response.json();
                return result?.candidates?.[0]?.content?.parts?.[0]?.text || "Keine Antwort erhalten.";
            } catch (error) {
                console.error("Fehler beim API-Aufruf:", error);
                return "Ein Fehler ist aufgetreten. Bitte versuchen Sie es erneut.";
            }
        }

        async function sendMessage(terminalId) {
            const terminal = document.getElementById(terminalId);
            const userInput = terminal.querySelector('.terminal-input');
            const messagesDiv = terminal.querySelector('.terminal-output');
            const message = userInput.value.trim();
            if (!message) return;

            displayMessage(messagesDiv, message, 'user');
            userInput.disabled = true;
            userInput.value = '';

            try {
                const botResponse = await getGeminiResponse(message);
                displayMessage(messagesDiv, botResponse, 'bot');
            } catch (error) {
                console.error("Fehler beim Senden der Nachricht:", error);
                displayMessage(messagesDiv, "Ein Fehler ist aufgetreten.", 'bot');
            } finally {
                userInput.disabled = false;
                userInput.focus();
            }
        }

        // =========================================================================
        // MEHRFACHFENSTER-LOGIK
        // =========================================================================
        let windowCounter = 0;

        function createWindow(title, contentHTML, initialSize = {width: '700px', height: '500px'}) {
            windowCounter++;
            const windowId = `window-${windowCounter}`;

            const newWindow = document.createElement('div');
            newWindow.id = windowId;
            newWindow.className = 'terminal-window';
            newWindow.style.zIndex = ++highestZIndex;
            newWindow.style.width = initialSize.width;
            newWindow.style.height = initialSize.height;

            // Positionierung leicht versetzt
            const offsetX = 50 + (windowCounter * 20) % (window.innerWidth - 800);
            const offsetY = 50 + (windowCounter * 20) % (window.innerHeight - 600);
            newWindow.style.left = `${offsetX}px`;
            newWindow.style.top = `${offsetY}px`;

            newWindow.innerHTML = `
                <div class="terminal-header">
                    <h2>${title}</h2>
                    <button class="close-btn">[ x ]</button>
                </div>
                ${contentHTML}
            `;

            document.body.appendChild(newWindow);
            desktop.style.display = 'none';
            newTerminalBtn.style.display = 'block';

            const header = newWindow.querySelector('.terminal-header');
            const closeBtn = newWindow.querySelector('.close-btn');

            newWindow.addEventListener('mousedown', () => {
                newWindow.style.zIndex = ++highestZIndex;
            });

            let isDragging = false;
            let dragOffsetX, dragOffsetY;

            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragOffsetX = e.clientX - newWindow.offsetLeft;
                dragOffsetY = e.clientY - newWindow.offsetTop;
                header.style.cursor = 'grabbing';
                document.body.style.userSelect = 'none'; 
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const newX = e.clientX - dragOffsetX;
                    const newY = e.clientY - dragOffsetY;
                    newWindow.style.left = `${newX}px`;
                    newWindow.style.top = `${newY}px`;
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    header.style.cursor = 'grab';
                    document.body.style.userSelect = 'auto';
                }
            });

            closeBtn.addEventListener('click', () => {
                newWindow.remove();
                if (document.querySelectorAll('.terminal-window').length === 0) {
                    desktop.style.display = 'flex';
                    newTerminalBtn.style.display = 'none';
                }
            });

            return newWindow;
        }
        
        function createTerminalWindow() {
            const terminalContent = `
                <div class="terminal-output">
                    <div class="log-entry">> Initialisiere Schnittstelle... [OK]</div>
                    <div class="log-entry">> Lade Module... [OK]</div>
                </div>
                <div class="terminal-input-container">
                    <span class="prompt-symbol">></span>
                    <input type="text" class="terminal-input" placeholder="Geben Sie Ihren Befehl ein..." autofocus>
                    <button class="sendBtn">Senden</button>
                </div>
            `;
            const terminalWindow = createWindow('TERMINAL', terminalContent);
            const userInput = terminalWindow.querySelector('.terminal-input');
            const sendBtn = terminalWindow.querySelector('.sendBtn');

            sendBtn.addEventListener('click', () => sendMessage(terminalWindow.id));
            userInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') sendMessage(terminalWindow.id);
            });
            userInput.focus();
        }

        // =========================================================================
        // ROBUSTER SKRIPT-LADER UND SCHACH-LOGIK
        // =========================================================================
        let chessScriptsLoaded = false;

        function loadScript(src) {
            return new Promise((resolve, reject) => {
                if (document.querySelector(`script[src="${src}"]`)) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = src;
                script.onload = () => resolve();
                script.onerror = () => reject(new Error(`Konnte Skript nicht laden: ${src}`));
                document.head.appendChild(script);
            });
        }
        
        // Globale Schachfiguren-Bilder
        const pieceImages = {
            'w': {'p':'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg','r':'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg','n':'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg','b':'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg','q':'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg','k':'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg'},
            'b': {'p':'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg','r':'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg','n':'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg','b':'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg','q':'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg','k':'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg'}
        };

        async function createChessWindow() {
          const initialContent = `<div class="chess-board-container" style="text-align: center; font-size: 1.5rem; padding: 40px;"><p>Lade Schach-Module...</p></div>`;
          const chessWindow = createWindow('Schach vs. Stockfish', initialContent, { width: 'auto', height: 'auto' });
          chessWindow.classList.add('chess-window');
          chessWindow.style.resize = 'none';

          const loaderDiv = chessWindow.querySelector('.chess-board-container');
          try {
            if (!chessScriptsLoaded) {
              await loadScript("https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js");
              chessScriptsLoaded = true;
            }
          } catch (error) {
            console.error(error);
            loaderDiv.innerHTML = '<p style="color: #FF0000;">Fehler beim Laden der Engine.</p>';
            return;
          }

          const gameContentHTML = `
            <div id="thinking-indicator">Stockfish denkt nach...</div>
            <div class="chess-board-container">
              <div class="chess-topbar">
                <div id="chess-status" class="chess-status">Weiß am Zug</div>
                <div class="chess-controls-right">
                  <div class="elo-control">
                    <label for="elo-slider">ELO: <span id="elo-value">1350</span></label>
                    <input type="range" id="elo-slider" min="0" max="40" value="10" title="Stockfish Skill Level">
                  </div>
                </div>
              </div>
              <div class="chess-board"></div>
              <div class="chess-control">
                <button id="new-game-btn" class="hacker-btn">[ ♻ Neues Spiel ]</button>
              </div>
            </div>
            <div id="promotion-modal" class="promotion-modal" aria-hidden="true">
              <div class="promotion-box">
                <div class="promotion-title">Bauernumwandlung</div>
                <div class="promotion-options">
                  <button class="promote-btn" data-piece="q">♕ Dame</button> <button class="promote-btn" data-piece="r">♖ Turm</button> <button class="promote-btn" data-piece="b">♗ Läufer</button> <button class="promote-btn" data-piece="n">♘ Springer</button>
                </div>
              </div>
            </div>
          `;
          loaderDiv.remove();
          chessWindow.querySelector('.terminal-header').insertAdjacentHTML('afterend', gameContentHTML);
          
          let game = new Chess();
          let stockfish = new Worker("js/stockfish.js");
          let gameHistory = [];
          let selectedSquare = null;
          let pendingPromotion = null;
          let isGameOver = false;

          const boardDiv = chessWindow.querySelector('.chess-board');
          const statusDiv = chessWindow.querySelector('#chess-status');
          const newGameBtn = chessWindow.querySelector('#new-game-btn');
          const thinkingIndicator = chessWindow.querySelector('#thinking-indicator');
          const promotionModal = chessWindow.querySelector('#promotion-modal');
          const eloSlider = chessWindow.querySelector('#elo-slider');
          const eloValueSpan = chessWindow.querySelector('#elo-value');

          function renderBoard() {
            boardDiv.innerHTML = '';
            const boardData = game.board();
            const history = game.history({ verbose: true });
            const lastMove = history.length > 0 ? history[history.length - 1] : null;

            for (let row = 0; row < 8; row++) {
              for (let col = 0; col < 8; col++) {
                const squareEl = document.createElement('div');
                const isLight = (row + col) % 2 === 0;
                squareEl.classList.add('chess-square', isLight ? 'light' : 'dark');
                const squareName = String.fromCharCode('a'.charCodeAt(0) + col) + (8 - row);
                squareEl.dataset.square = squareName;

                if (lastMove) {
                  if (lastMove.from === squareName) squareEl.classList.add('last-move-from');
                  if (lastMove.to === squareName) squareEl.classList.add('last-move-to');
                }

                const piece = boardData[row][col];
                if (piece) {
                  const img = document.createElement('img');
                  img.src = pieceImages[piece.color][piece.type];
                  img.className = 'chess-piece-img';
                  squareEl.appendChild(img);
                }
                squareEl.addEventListener('click', handleSquareClick);
                boardDiv.appendChild(squareEl);
              }
            }
          }

          function updateStatus() {
            let statusText = game.turn() === 'w' ? 'Weiß am Zug' : 'Schwarz (Bot) am Zug';
            if (game.in_checkmate()) statusText = `Schachmatt! ${game.turn() === 'w' ? 'Schwarz' : 'Weiß'} gewinnt.`;
            else if (game.in_stalemate() || game.in_threefold_repetition() || game.in_draw()) statusText = 'Patt! Unentschieden.';
            else if (game.in_check()) statusText += ' (im Schach)';
            statusDiv.textContent = statusText;
          }
          
          function handleSquareClick(event) {
            if (game.turn() !== 'w' || game.game_over() || isGameOver) return;
            const clickedSquareName = event.currentTarget.dataset.square;

            if (selectedSquare) {
              const from = selectedSquare.dataset.square;
              const to = clickedSquareName;
              const move = game.moves({ square: from, verbose: true }).find(m => m.to === to);

              if (move) {
                if (move.flags.includes('p')) {
                  pendingPromotion = { from, to };
                  promotionModal.classList.add('visible');
                } else {
                  makeMove(from, to);
                }
              }
              selectedSquare.classList.remove('selected');
              document.querySelectorAll('.highlight-move, .highlight-capture').forEach(sq => sq.classList.remove('highlight-move', 'highlight-capture'));
              selectedSquare = null;
            } else {
              const piece = game.get(clickedSquareName);
              if (piece && piece.color === 'w') {
                selectedSquare = event.currentTarget;
                selectedSquare.classList.add('selected');
                highlightValidMoves(clickedSquareName);
              }
            }
          }
          
          function highlightValidMoves(square) {
            const moves = game.moves({ square: square, verbose: true });
            moves.forEach(move => {
              const targetSquare = boardDiv.querySelector(`[data-square="${move.to}"]`);
              if (targetSquare) targetSquare.classList.add(move.flags.includes('c') ? 'highlight-capture' : 'highlight-move');
            });
          }

          function makeMove(from, to, promotion) {
            const moveResult = game.move({ from, to, promotion });
            if (moveResult) {
              gameHistory.push(game.fen());
              renderBoard();
              updateStatus();

              if (game.game_over()) {
                  isGameOver = true;
                  showGameOverPrompt();
              } else {
                setTimeout(makeBotMove, 250);
              }
            }
            return moveResult;
          }

          promotionModal.querySelectorAll('.promote-btn').forEach(btn => {
              btn.onclick = () => {
                if (!pendingPromotion) return;
                const { from, to } = pendingPromotion;
                makeMove(from, to, btn.dataset.piece);
                promotionModal.classList.remove('visible');
                pendingPromotion = null;
              };
          });

          function makeBotMove() {
            if (game.turn() === 'b' && !game.game_over()) {
              thinkingIndicator.style.display = 'block';
              const skillLevel = Math.min(20, parseInt(eloSlider.value, 10) || 10);
              stockfish.postMessage(`setoption name Skill Level value ${skillLevel}`);
              stockfish.postMessage(`position fen ${game.fen()}`);
              stockfish.postMessage(`go movetime 500`);
            }
          }

          stockfish.onmessage = function(event) {
            const message = event.data || event;
            if (typeof message === 'string' && message.startsWith('bestmove')) {
              thinkingIndicator.style.display = 'none';
              const move = message.split(' ')[1];
              const from = move.substring(0, 2);
              const to = move.substring(2, 4);
              const promotion = move.length > 4 ? move.substring(4) : undefined;
              game.move({ from, to, promotion });
              gameHistory.push(game.fen());
              renderBoard();
              updateStatus();
              if (game.game_over()) {
                  isGameOver = true;
                  showGameOverPrompt();
              }
            }
          };
          
          function saveCurrentGame() {
              if (game.history().length === 0) return;
              try {
                  const saved = JSON.parse(localStorage.getItem('savedGames') || '[]');
                  saved.push({ pgn: game.pgn(), fens: [...gameHistory], date: new Date().toISOString() });
                  localStorage.setItem('savedGames', JSON.stringify(saved));
              } catch (e) { console.warn('Save failed', e); }
          }
          
          function showGameOverPrompt(isRestart = false) {
              const template = document.getElementById('game-over-modal-template');
              const modalClone = template.content.cloneNode(true);
              document.body.appendChild(modalClone);

              const modalElement = document.body.lastElementChild;
              const titleEl = modalElement.querySelector('#modal-title');
              const textEl = modalElement.querySelector('#modal-text');
              const saveBtn = modalElement.querySelector('#modal-action-save');
              const newBtn = modalElement.querySelector('#modal-action-new');
              const closeBtn = modalElement.querySelector('#modal-action-close');

              if (isRestart) {
                  titleEl.textContent = "Partie läuft";
                  textEl.textContent = "Möchtest du die aktuelle Partie speichern, bevor du eine neue startest?";
              } else {
                  titleEl.textContent = "Partie beendet!";
                  textEl.textContent = `Möchtest du die Partie speichern? (${statusDiv.textContent})`;
              }

              saveBtn.onclick = () => {
                  saveCurrentGame();
                  if (isRestart) initializeGame();
                  modalElement.remove();
              };
              newBtn.onclick = () => {
                  initializeGame();
                  modalElement.remove();
              };
              closeBtn.onclick = () => {
                  modalElement.remove();
              };
          }

          newGameBtn.addEventListener('click', () => {
              if (game.history().length > 0 && !isGameOver) {
                  showGameOverPrompt(true);
              } else {
                  initializeGame();
              }
          });
          
          eloSlider.addEventListener('input', (e) => {
              const sliderValue = parseInt(e.target.value, 10);
              const minElo = 800, maxElo = 3500;
              eloValueSpan.textContent = Math.round(minElo + (sliderValue / 40) * (maxElo - minElo));
          });

          function initializeGame() {
            game.reset();
            gameHistory = [];
            selectedSquare = null;
            pendingPromotion = null;
            isGameOver = false;
            stockfish.postMessage('ucinewgame');
            renderBoard();
            updateStatus();
          }

          initializeGame();
        }

        function createReplayApp() {
            const content = `
                <div class="replay-viewer-container">
                    <div class="replay-controls-top">
                        <input id="replay-search-input" type="text" placeholder="Suche nach Datum oder PGN...">
                        <button id="replay-import-btn" class="hacker-btn">Import</button>
                        <button id="replay-refresh-btn" class="hacker-btn">Refresh</button>
                    </div>
                    <div class="replay-list-container"></div>
                    <input type="file" id="replay-file-input" accept=".json,.pgn" style="display:none;">
                </div>
            `;
            const replayWindow = createWindow('Replay Viewer', content, {width:'800px', height:'600px'});

            const searchInput = replayWindow.querySelector('#replay-search-input');
            const importBtn = replayWindow.querySelector('#replay-import-btn');
            const refreshBtn = replayWindow.querySelector('#replay-refresh-btn');
            const listContainer = replayWindow.querySelector('.replay-list-container');
            const fileInput = replayWindow.querySelector('#replay-file-input');

            let currentGames = [];
            
            function renderList(filter = '') {
                listContainer.innerHTML = '';
                const filtered = currentGames.filter(g => {
                    if (!filter) return true;
                    const fLower = filter.toLowerCase();
                    return (g.date && g.date.toLowerCase().includes(fLower)) || (g.pgn && g.pgn.toLowerCase().includes(fLower));
                });

                if (filtered.length === 0) {
                    listContainer.innerHTML = '<p>Keine Partien gefunden.</p>';
                    return;
                }
                
                filtered.forEach((gameData, originalIndex) => {
                    const item = document.createElement('div');
                    item.className = 'replay-list-item';
                    item.innerHTML = `
                        <div>
                            <strong>${new Date(gameData.date).toLocaleString()}</strong>
                            <div style="font-size:0.8rem; opacity:0.7;">${gameData.pgn.split('\n')[0].slice(0, 60)}...</div>
                        </div>
                        <button class="hacker-btn">Öffnen</button>
                    `;
                    item.querySelector('button').onclick = (e) => {
                        e.stopPropagation();
                        openPlayer(gameData.fens);
                    };
                    listContainer.appendChild(item);
                });
            }

            function openPlayer(fens) {
                if (document.querySelector('.replay-player-container')) return;

                const playerEl = document.createElement('div');
                playerEl.className = 'replay-player-container';
                playerEl.innerHTML = `
                    <div id="replay-board-viewer" class="chess-board"></div>
                    <div class="replay-player-controls">
                        <button id="player-prev" class="hacker-btn">◀</button>
                        <span id="replay-pos-viewer">0/0</span>
                        <button id="player-next" class="hacker-btn">▶</button>
                        <button id="player-close" class="hacker-btn">Schließen</button>
                    </div>
                `;
                document.body.appendChild(playerEl);
                
                const boardEl = playerEl.querySelector('#replay-board-viewer');
                const posEl = playerEl.querySelector('#replay-pos-viewer');
                const prevBtn = playerEl.querySelector('#player-prev');
                const nextBtn = playerEl.querySelector('#player-next');
                const closeBtn = playerEl.querySelector('#player-close');

                let viewerGame = new Chess();
                let currentIndex = 0;
                
                function renderReplayBoard() {
                    boardEl.innerHTML = '';
                    const boardData = viewerGame.board();
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const squareEl = document.createElement('div');
                            squareEl.className = `chess-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                            const piece = boardData[row][col];
                            if (piece) {
                                const img = document.createElement('img');
                                img.src = pieceImages[piece.color][piece.type];
                                img.className = 'chess-piece-img';
                                squareEl.appendChild(img);
                            }
                            boardEl.appendChild(squareEl);
                        }
                    }
                }
                
                function updatePlayerState() {
                    viewerGame.load(fens[currentIndex]);
                    posEl.textContent = `${currentIndex + 1}/${fens.length}`;
                    renderReplayBoard();
                }

                const keyHandler = (e) => {
                    if (e.key === 'ArrowLeft') {
                        if (currentIndex > 0) { currentIndex--; updatePlayerState(); }
                    } else if (e.key === 'ArrowRight') {
                        if (currentIndex < fens.length - 1) { currentIndex++; updatePlayerState(); }
                    } else if (e.key === 'Escape') {
                        closePlayer();
                    }
                };

                function closePlayer() {
                    document.removeEventListener('keydown', keyHandler);
                    playerEl.remove();
                }

                prevBtn.onclick = () => { if (currentIndex > 0) { currentIndex--; updatePlayerState(); } };
                nextBtn.onclick = () => { if (currentIndex < fens.length - 1) { currentIndex++; updatePlayerState(); } };
                closeBtn.onclick = closePlayer;

                document.addEventListener('keydown', keyHandler);
                updatePlayerState();
            }

            function loadAndRender() {
                try {
                    currentGames = JSON.parse(localStorage.getItem('savedGames') || '[]').reverse();
                    renderList(searchInput.value);
                } catch(e) { console.error("Could not load games", e); }
            }

            searchInput.addEventListener('input', () => renderList(searchInput.value));
            refreshBtn.addEventListener('click', loadAndRender);
            importBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        let gamesToSave = Array.isArray(importedData) ? importedData : [importedData];
                        const allGames = JSON.parse(localStorage.getItem('savedGames') || '[]');
                        allGames.push(...gamesToSave);
                        localStorage.setItem('savedGames', JSON.stringify(allGames));
                        loadAndRender();
                    } catch (err) {
                        alert('Import fehlgeschlagen. Bitte stelle sicher, dass es eine gültige JSON-Datei ist.');
                    }
                };
                reader.readAsText(file);
                fileInput.value = ''; // Reset for next import
            });

            loadAndRender();
        }

        // =========================================================================
        // BOOT-SEQUENZ
        // =========================================================================
        const loadingPhases = [
            {title: "PHASE 1: SYSTEM-KERNEL LADEN", logs: [{text: "Initialisiere Core-Module...", delay: 600, status: "OK"}, {text: "Prüfe Speicherintegrität...", delay: 500, status: "OK"}], progress: 33},
            {title: "PHASE 2: NETZWERK-PROTOKOLLE", logs: [{text: "WARNUNG: Fremdzugriff auf Port 80...", delay: 800, status: "WARN"}, {text: "Isoliere verdächtige Verbindung...", delay: 1000, status: "INFO"}, {text: "Netzwerk gesichert.", delay: 400, status: "SUCCESS"}], progress: 66},
            {title: "PHASE 3: KERNKOMPONENTEN STARTEN", logs: [{text: "Rendere Partikel-Matrix...", delay: 700, status: "OK"}, {text: "Berechne Vektoren...", delay: 900, status: "OK"}], progress: 100, action: () => {animationPhase = 'xInflow';}}
        ];

        async function runBootSequence() {
            loadingLog.style.opacity = 1;
            progressBarContainer.style.opacity = 1;
            let currentProgress = 0;
            for (const phase of loadingPhases) {
                loadingText.textContent = phase.title;
                for (const log of phase.logs) {
                    const newLogLine = document.createElement('p');
                    newLogLine.classList.add('log-line');
                    newLogLine.innerHTML = `> <span class="status-${log.status.toLowerCase()}">[ ${log.status} ]</span> ${log.text}`;
                    loadingLog.appendChild(newLogLine);
                    loadingLog.scrollTop = loadingLog.scrollHeight;
                    await new Promise(r => setTimeout(r, log.delay));
                }
                if (phase.action) phase.action();
                updateProgressBar(currentProgress, phase.progress, 500);
                currentProgress = phase.progress;
                await new Promise(r => setTimeout(r, 800));
            }
            await new Promise(r => setTimeout(r, 2500));
            showDesktop();
        }

        function updateProgressBar(startWidth, targetWidth, duration) {
            const startTime = performance.now();
            function step(timestamp) {
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                progressBar.style.width = (startWidth + (targetWidth - startWidth) * easeProgress) + '%';
                if (progress < 1) window.requestAnimationFrame(step);
            }
            window.requestAnimationFrame(step);
        }

        async function showDesktop() {
            loadingText.style.opacity = 0;
            accessGranted.style.display = 'block';
            accessGranted.style.opacity = 1;
            await new Promise(r => setTimeout(r, 2000));
            accessGranted.style.opacity = 0;
            await new Promise(r => setTimeout(r, 1000));
            loader.style.display = 'none';
            desktop.style.display = 'flex';
        }

        // --- Event-Listener und Initialisierung ---
        newTerminalBtn.addEventListener('click', createTerminalWindow);
        consoleIcon.addEventListener('click', createTerminalWindow);
        chessIcon.addEventListener('click', createChessWindow);
        replayIcon.addEventListener('click', createReplayApp);
        window.onload = () => {init3D(); animate3D(); runBootSequence();};
    </script>
</body>
</html>
